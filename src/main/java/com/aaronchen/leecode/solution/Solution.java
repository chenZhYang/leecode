package com.aaronchen.leecode.solution;

import com.aaronchen.leecode.addtwonumbers.ListNode;
import com.aaronchen.leecode.diameterofbinarytree.TreeNode;

/**
 * @Author: Aaron chen
 * @Date: 2020/2/24 0:22
 */
public abstract class Solution {
    /**
     * 计算整数反转
     * @param x
     * @return
     */
    public int reverse(int x){
        return 0;
    }

    /**
     * 回文数
     * @param x
     * @return
     */
    public boolean isPalindrome(int x) {
        return true;
    }

    /**
     * 罗马数字转整数
     * @param s
     * @return
     */
    public  int romanToInt(String s) { return 0;}

    /**
     * 最长公共前缀
     * @param strs
     * @return
     */
    public String longestCommonPrefix(String[] strs) {
        return null;
    }

    /**
     * 合并两个有序链表
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        return null;
    }

    /**
     * 删除排序数组中的重复项
     * @param nums
     * @return
     */
    public int removeDuplicates(int[] nums) {
        return 0;
    }

    /**
     * 移除元素
     * @param nums
     * @param val
     * @return
     */
    public int removeElement(int[] nums, int val) {
        return 0;
    }

    /**
     * 实现 strStr() 函数
     * @param haystack
     * @param needle
     * @return
     */
    public int strStr(String haystack, String needle) {
        return 0;
    }

    /**
     * 搜索插入位置
     * @param nums
     * @param target
     * @return
     */
    public int searchInsert(int[] nums, int target) {
        return 0;
    }

    /**
     * 反转链表
     * @param head
     * @return 返回反转后的链表
     */
    public ListNode reverseList(ListNode head) {
        return null;
    }

    /**
     * 合并排序数组
     * @param A
     * @param m
     * @param B
     * @param n
     */
    public void mergeArray(int[] A, int m, int[] B, int n) {
    }

    /**
     * 腐烂的橘子
     * @param grid
     * @return
     */
    public int orangesRotting(int[][] grid) {
        return 0;
    }

    /**
     * 分糖果 II
     * @param candies
     * @param num_people
     * @return
     */
    public int[] distributeCandies(int candies, int num_people) {
        return null;
    }

    /**
     * 和为s的连续正数序列
     * @param target
     * @return
     */
    public int[][] findContinuousSequence(int target) {
        return null;
    }

    /**
     *
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices) {
        return 0;
    }

    /**
     * 零钱兑换
     * @param coins
     * @param amount
     * @return
     */
    public int coinChange(int[] coins, int amount) {
        return 0;
    }

    /**
     * 二叉树的直径
     * @param root
     * @return
     */
    public int diameterOfBinaryTree(TreeNode root) {
        return 0;
    }

    /**
     * 将数组分成和相等的三个部分
     * @param A
     * @return
     */
    public boolean canThreePartsEqualSum(int[] A) {
        return true;
    }

    /**
     * 字符串的最大公因子
     * @param str1
     * @param str2
     * @return
     */
    public String gcdOfStrings(String str1, String str2) {
        return null;
    }
}
