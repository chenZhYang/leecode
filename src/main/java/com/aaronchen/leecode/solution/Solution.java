package com.aaronchen.leecode.solution;

import com.aaronchen.leecode.addtwonumbers.ListNode;
import com.aaronchen.leecode.diameterofbinarytree.TreeNode;

/**
 * @Author: Aaron chen
 * @Date: 2020/2/24 0:22
 */
public abstract class Solution {
    /**
     * 计算整数反转
     * @param x
     * @return
     */
    public int reverse(int x){
        return 0;
    }

    /**
     * 回文数
     * @param x
     * @return
     */
    public boolean isPalindrome(int x) {
        return true;
    }

    /**
     * 罗马数字转整数
     * @param s
     * @return
     */
    public  int romanToInt(String s) { return 0;}

    /**
     * 最长公共前缀
     * @param strs
     * @return
     */
    public String longestCommonPrefix(String[] strs) {
        return null;
    }

    /**
     * 合并两个有序链表
     * @param l1
     * @param l2
     * @return
     */
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        return null;
    }

    /**
     * 删除排序数组中的重复项
     * @param nums
     * @return
     */
    public int removeDuplicates(int[] nums) {
        return 0;
    }

    /**
     * 移除元素
     * @param nums
     * @param val
     * @return
     */
    public int removeElement(int[] nums, int val) {
        return 0;
    }

    /**
     * 实现 strStr() 函数
     * @param haystack
     * @param needle
     * @return
     */
    public int strStr(String haystack, String needle) {
        return 0;
    }

    /**
     * 搜索插入位置
     * @param nums
     * @param target
     * @return
     */
    public int searchInsert(int[] nums, int target) {
        return 0;
    }

    /**
     * 反转链表
     * @param head
     * @return 返回反转后的链表
     */
    public ListNode reverseList(ListNode head) {
        return null;
    }

    /**
     * 合并排序数组
     * @param A
     * @param m
     * @param B
     * @param n
     */
    public void mergeArray(int[] A, int m, int[] B, int n) {
    }

    /**
     * 腐烂的橘子
     * @param grid
     * @return
     */
    public int orangesRotting(int[][] grid) {
        return 0;
    }

    /**
     * 分糖果 II
     * @param candies
     * @param num_people
     * @return
     */
    public int[] distributeCandies(int candies, int num_people) {
        return null;
    }

    /**
     * 和为s的连续正数序列
     * @param target
     * @return
     */
    public int[][] findContinuousSequence(int target) {
        return null;
    }

    /**
     *
     * @param prices
     * @return
     */
    public int maxProfit(int[] prices) {
        return 0;
    }

    /**
     * 零钱兑换
     * @param coins
     * @param amount
     * @return
     */
    public int coinChange(int[] coins, int amount) {
        return 0;
    }

    /**
     * 二叉树的直径
     * @param root
     * @return
     */
    public int diameterOfBinaryTree(TreeNode root) {
        return 0;
    }

    /**
     * 将数组分成和相等的三个部分
     * @param A
     * @return
     */
    public boolean canThreePartsEqualSum(int[] A) {
        return true;
    }

    /**
     * 字符串的最大公因子
     * @param str1
     * @param str2
     * @return
     */
    public String gcdOfStrings(String str1, String str2) {
        return null;
    }

    /**
     * 多数元素
     * @param nums
     * @return
     */
    public int majorityElement(int[] nums) {
        return 0;
    }

    /**
     * 外观数列
     * @param n
     * @return
     */
    public String countAndSay(int n) {
        return null;
    }

    /**
     * 最长上升子序列
     * @param nums
     * @return
     */
    public int lengthOfLIS(int[] nums) {
        return 0;
    }

    /**
     * 岛屿的最大面积
     * @param grid
     * @return
     */
    public int maxAreaOfIsland(int[][] grid) {
        return 0;
    }

    /**
     * 字符串压缩
     * @param S
     * @return
     */
    public String compressString(String S) {
        return null;
    }

    /**
     * 最大子序和
     * @param nums
     * @return
     */
    public int maxSubArray(int[] nums) {
        return 0;
    }

    /**
     * 拼写单词
     * @param words
     * @param chars
     * @return
     */
    public int countCharacters(String[] words, String chars) {
        return 0;
    }

    /**
     * 矩形重叠
     * @param rec1
     * @param rec2
     * @return
     */
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
        return true;
    }

    /**
     * 最长回文串
     * @param s
     * @return
     */
    public int longestPalindrome(String s) {
        return 0;
    }

    /**
     * 最小的k个数
     * @param arr
     * @param k
     * @return
     */
    public int[] getLeastNumbers(int[] arr, int k) {
        return null;
    }

    /**
     * 使数组唯一的最小增量
     * @param A
     * @return
     */
    public int minIncrementForUnique(int[] A) {
        return 0;
    }

    /**
     * 链表的中间结点
     * @param head
     * @return
     */
    public ListNode middleNode(ListNode head) {
        return null;
    }

    /**
     * 按摩师
     * @param nums
     * @return
     */
    public int massage(int[] nums) {
        return 0;
    }

    /**
     * 三维形体的表面积
     * @param grid
     * @return
     */
    public int surfaceArea(int[][] grid) {
        return 0;
    }

    /**
     * 车的可用捕获量
     * @param board
     * @return
     */
    public int numRookCaptures(char[][] board) {
        return 0;
    }

    /**
     * 卡牌分组
     * @param deck
     * @return
     */
    public boolean hasGroupsSizeX(int[] deck) {
        return false;
    }

    /**
     * 单词的压缩编码
     * @param words
     * @return
     */
    public int minimumLengthEncoding(String[] words) {
        return 0;
    }

    /**
     * 地图分析
     * @param grid
     * @return
     */
    public int maxDistance(int[][] grid) {
        return 0;
    }

    /**
     * 圆圈中最后剩下的数字
     * @param n
     * @param m
     * @return
     */
    public int lastRemaining(int n, int m) {
        return 0;
    }

    /**
     * 排序数组
     * @param nums
     * @return
     */
    public int[] sortArray(int[] nums) {
        return nums;
    }
}
